# Chapter 01-03
**LeetCode 937. Reorder Data in Log Files**

## Table of contents
1. [ë¬¸ì œ ì„¤ëª…](#1-ë¬¸ì œ-ì„¤ëª…)
1. [ë¬¸ì œ ì ‘ê·¼ ë°©ë²•](#2-ë¬¸ì œ-ì ‘ê·¼-ë°©ë²•)
1. [ì•Œê³ ë¦¬ì¦˜ ìˆœì„œë„](#3-ì•Œê³ ë¦¬ì¦˜-ìˆœì„œë„)
1. [ì½”ë“œ](#4-ì½”ë“œ)
1. [ë³µì¡ë„ ë¶„ì„](#5-ë³µì¡ë„-ë¶„ì„)
1. [ë‹¤ë¥¸ í’€ì´ ë°©ë²•](#6-ë‹¤ë¥¸-í’€ì´-ë°©ë²•)

---

## 1. ë¬¸ì œ ì„¤ëª…

```text
You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.

There are two types of logs:

Letter-logs: All words (except the identifier) consist of lowercase English letters.
Digit-logs: All words (except the identifier) consist of digits.
Reorder these logs so that:

The letter-logs come before all digit-logs.
The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.
The digit-logs maintain their relative ordering.
Return the final order of the logs.
```

#### Constraints:
- `1 <= logs.length <= 100`
- `3 <= logs[i].length <= 100`
- All the tokens of `logs[i]` are separated by a single space.
- `logs[i]` is guaranteed to have an identifier and at least one word after the identifier.

#### ì˜ˆì‹œ

```bash
Input:
logs = [
  "dig1 8 1 5 1",
  "let1 art can",
  "dig2 3 6",
  "let2 own kit dig",
  "let3 art zero"
]

---

Output:
[
  "let1 art can",
  "let3 art zero",
  "let2 own kit dig",
  "dig1 8 1 5 1",
  "dig2 3 6"
]
```

### ë¬¸ì œ ì •ë¦¬

```bash
# ë¡œê·¸ì˜ êµ¬ì„±
<identifier> <content>

# identifier: ì˜ë¬¸ ì†Œë¬¸ì or ìˆ«ìë¡œ êµ¬ì„±ëœ ê³ ìœ  ì‹ë³„ì
# content: ì˜ë¬¸ ì†Œë¬¸ì ë˜ëŠ” ìˆ«ìë¡œ êµ¬ì„±ëœ ë‹¨ì–´ë“¤ (ê³µë°±ìœ¼ë¡œ êµ¬ë¶„)
```


> 1. ëª¨ë“  ë¬¸ì ë¡œê·¸ëŠ” ìˆ«ì ë¡œê·¸ë³´ë‹¤ ì•ì— ì™€ì•¼ í•¨
> 2. ë¬¸ì ë¡œê·¸ëŠ” ë‹¤ìŒì˜ ìš°ì„ ìˆœìœ„ë¡œ ì •ë ¬í•´ì•¼ í•¨:
>   - content ê¸°ì¤€ìœ¼ë¡œ ì‚¬ì „ ìˆœ
>   - ë§Œì•½ contentê°€ ê°™ë‹¤ë©´, identifier ê¸°ì¤€ìœ¼ë¡œ ì‚¬ì „ ìˆœ
> 3. ìˆ«ì ë¡œê·¸ëŠ” ì…ë ¥ ìˆœì„œë¥¼ ê·¸ëŒ€ë¡œ ìœ ì§€í•´ì•¼ í•¨


---

## 2. ë¬¸ì œ ì ‘ê·¼ ë°©ë²•

### í•µì‹¬ ì•„ì´ë””ì–´
1. ê° ë¡œê·¸ë¥¼ ë¬¸ì ë¡œê·¸ì™€ ìˆ«ì ë¡œê·¸ë¡œ êµ¬ë¶„
1. ë¬¸ì ë¡œê·¸ëŠ” `ë‚´ìš©(content)` â†’ `ì‹ë³„ì(identifier)` ìˆœìœ¼ë¡œ ì •ë ¬
1. ìˆ«ì ë¡œê·¸ëŠ” ì›ë˜ì˜ ìˆœì„œ ìœ ì§€
1. ìµœì¢…ì ìœ¼ë¡œ ë¬¸ì ë¡œê·¸ì— ìˆ«ì ë¡œê·¸ë¥¼ ì´ì–´ ë¶™ì„

---

## 3. ì•Œê³ ë¦¬ì¦˜ ìˆœì„œë„

```mermaid
flowchart TD
  A["ì…ë ¥ ë¡œê·¸ ë°°ì—´ logs[]"] --> B{ë¬¸ì ë¡œê·¸ì¸ê°€?}
  B -- ì˜ˆ --> C[letterLogs ë°°ì—´ì— ì €ì¥]
  B -- ì•„ë‹ˆì˜¤ --> D[digitLogs ë°°ì—´ì— ì €ì¥]
  C & D --> E["letterLogs ì •ë ¬ (ë‚´ìš© > ì‹ë³„ì)"]
  E --> F[ì •ë ¬ëœ letterLogs + digitLogs ë°˜í™˜]
```
___

## 4. ì½”ë“œ

### ë¬¸ì ë¡œê·¸ì™€ ìˆ«ì ë¡œê·¸ë¡œ êµ¬ë¶„

```ts
function isDigitLog(log: string) {
  const [id, ...rest] = log.split(' ');
  return /\d/.test(rest[0]);
}

// ---

function reorderLogFiles(logs: string[]): string[] {
  for (const log of logs) {
    if (isDigitLog(log)) {
      digitLogs.push(log); // ìˆ«ìë¡œ ì‹œì‘í•˜ë©´ ìˆ«ì ë¡œê·¸
    } else {
      letterLogs.push(log); // ë¬¸ìê°€ ì‹œì‘ì´ë©´ ë¬¸ì ë¡œê·¸
    }
  }

  // ...
}
```

### ë¬¸ì ë¡œê·¸ëŠ” contentì™€ ì‹ë³„ìë¡œ ë‚˜ëˆ  ì •ë ¬

#### ì‚¬ì „ìˆœ ë¹„êµë¥¼ ìœ„í•´ localeCompare() í™œìš©
`localeCompare()`ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ ë¬¸ìì—´ ë¹„êµ í•¨ìˆ˜

```ts
'apple'.localeCompare('banana'); // -1 (apple < banana)
'banana'.localeCompare('apple'); // 1  (banana > apple)
'apple'.localeCompare('apple');  // 0  (ê°™ìŒ)
```

```ts
letterLogs.sort((a, b) => {
  // ê° ë¡œê·¸ë¥¼ ê³µë°± ê¸°ì¤€ìœ¼ë¡œ ë‚˜ëˆ”
  const [idA, ...restA] = a.split(' '); // ì˜ˆ: "let1 art can" => idA = "let1", restA = ["art", "can"]
  const [idB, ...restB] = b.split(' '); // ì˜ˆ: "let2 own kit" => idB = "let2", restB = ["own", "kit"]

  const contentA = restA.join(' ');
  const contentB = restB.join(' ');

  // 1. contentê°€ ê°™ìœ¼ë©´ idë¥¼ ì‚¬ì „ìˆœìœ¼ë¡œ ë¹„êµ
  if (contentA === contentB) {
    return idA.localeCompare(idB);
    // ì˜ˆ: "let1" < "let2" â†’ -1 ë°˜í™˜ â†’ aê°€ ì•ì— ì˜¤ë„ë¡
  }
  
  // 2. contentë¼ë¦¬ ì‚¬ì „ ìˆœ ë¹„êµ
  return contentA.localeCompare(contentB);
  // ì˜ˆ: "art can" < "own kit" â†’ -1 ë°˜í™˜ â†’ aê°€ ì•ì— ì˜¤ë„ë¡
});
```

---

## 5. ë³µì¡ë„ ë¶„ì„

### ì‹œê°„ ë³µì¡ë„ â³
> 1.	ë°˜ë³µë¬¸ì˜ ì‹¤í–‰ íšŸìˆ˜ë¥¼ ë¨¼ì € ë³´ê¸°
> 2.	ë°˜ë³µ ì•ˆì—ì„œ ì‹¤í–‰ë˜ëŠ” ì—°ì‚° ìˆ˜ë¥¼ ì²´í¬
> 3.	ì…ë ¥ì˜ í¬ê¸°(n)ì— ë”°ë¼ ì–¼ë§ˆë‚˜ ì‹œê°„ì´ ëŠ˜ì–´ë‚˜ëŠ”ì§€ íŒë‹¨

#### ë¡œê·¸ ë¶„ë¥˜
ë¬¸ì ë¡œê·¸ì™€ ìˆ«ì ë¡œê·¸ë¡œ êµ¬ë¶„í•˜ëŠ” ë¶€ë¶„ ì‹œê°„ ë³µì¡ë„ ë¶„ì„
- `logs.length = N`ì´ë¼ë©´, ì´ ë°˜ë³µë¬¸ì€ Në²ˆ ì‹¤í–‰
- ê° `log.split(' ')`ëŠ” í‰ê· ì ìœ¼ë¡œ Kê°œì˜ ë‹¨ì–´ë¥¼ ë‚˜ëˆ„ëŠ”ë°, ìµœëŒ€ ê¸¸ì´ê°€ 100ì´ë¼ ìƒìˆ˜ë¡œ ê°„ì£¼ â†’ O(1)
- `/\d/.test(rest[0])` ë„ O(1)

**ì´ ë¶€ë¶„ ì‹œê°„ ë³µì¡ë„**: O(N)

#### ë¬¸ì ë¡œê·¸ ì •ë ¬
ë¬¸ì ë¡œê·¸ë¥¼ `ë‚´ìš©(content)` â†’ `ì‹ë³„ì(identifier)` ìˆœìœ¼ë¡œ ì •ë ¬í•˜ëŠ” ë¶€ë¶„ ì‹œê°„ ë³µì¡ë„ ë¶„ì„

- `letterLogs.length = L`ì´ë¼ í•˜ì (L â‰¤ N)
- ì •ë ¬ ìì²´ëŠ” ì¼ë°˜ì ìœ¼ë¡œ O(L log L)
  - JavaScriptì˜ sortëŠ” TimSort ê¸°ë°˜: í‰ê· /ìµœì•… O(N log N)
- ë‹¤ë§Œ ë¹„êµ í•¨ìˆ˜ ì•ˆì—ì„œ:
  - split(' '): O(K)
  - join(' '): O(K)
  - localeCompare: ë‘ ë¬¸ìì—´ì˜ ê¸¸ì´ = ìµœëŒ€ 100 â†’ O(K)
  - ê·¸ë˜ì„œ **í•œ ë²ˆì˜ ë¹„êµ ì—°ì‚°ì€ O(K)** (KëŠ” í•œ logì˜ í‰ê·  ë‹¨ì–´ ìˆ˜ ë˜ëŠ” ê¸¸ì´)

**ì´ ë¶€ë¶„ ì‹œê°„ ë³µì¡ë„**: O(N log N)  

#### ìš”ì•½
> ì „ì²´ ì •ë ¬ ë³µì¡ë„: O(L log L Ã— K)
> - ê·¸ëŸ°ë° KëŠ” ìµœëŒ€ 100ì´ë¯€ë¡œ â†’ O(L log L)
> - ì¦‰, O(N log N)

**ì‹œê°„ ë³µì¡ë„**: O(N log N)

### ê³µê°„ ë³µì¡ë„ ğŸ—ƒï¸
> 1. ë°°ì—´, ê°ì²´ ë“± ì¶”ê°€ì ì¸ ìë£Œêµ¬ì¡°ë¥¼ ìƒˆë¡œ ë§Œë“¤ì—ˆëŠ”ì§€ ë³´ê¸°
> 2. ê·¸ ìë£Œêµ¬ì¡°ì˜ í¬ê¸°ê°€ ì…ë ¥ í¬ê¸°(n)ì— ë¹„ë¡€í•˜ëŠ”ì§€ ì²´í¬
> 3. ë³€ìˆ˜ë§Œ ì‚¬ìš©í•œ ê²½ìš°ëŠ” O(1)ë¡œ ë´„

#### ì¶”ê°€ ë°°ì—´ì˜ ì‚¬ìš©

```ts
const letterLogs: string[] = [];
const digitLogs: string[] = [];
```

- ì´ Nê°œì˜ ë¡œê·¸ë¥¼ 2ê°œì˜ ë°°ì—´ë¡œ ë‚˜ëˆ  ì €ì¥í•¨
- letterLogs + digitLogs = N
- ê° ë¡œê·¸ëŠ” stringì´ë¯€ë¡œ â†’ O(N)

**ê³µê°„ ë³µì¡ë„**: O(N)

### Big-O ë¶„ì„ ìš”ì•½
- í‰ê·  ì‹œê°„ ë³µì¡ë„: O(N log N)
- ìµœì•… ì‹œê°„ ë³µì¡ë„: O(N log N)
- ê³µê°„ ë³µì¡ë„: O(N)

---

## 6. ë‹¤ë¥¸ í’€ì´ ë°©ë²•

- `String.prototype.indexOf()`ì˜ ì‚¬ìš©
