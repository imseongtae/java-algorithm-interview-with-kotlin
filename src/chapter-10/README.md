# Chapter-10


## Table of contents
1. [Design Circular Deque](#1-design-circular-deque)
1. [Merge k Sorted Lists](#2-merge-k-sorted-lists)
1. [K Closest Points to Origin](#3-k-closest-points-to-origin)
1. []
---

## 1. Design Circular Deque

### 문제 이해
원형 덱을 설계하는 문제이며, 원형 덱은 아래의 연산을 지원해야 함

- insertFront(): 덱의 앞쪽에 요소를 삽입
- insertLast(): 덱의 뒤쪽에 요소를 삽입
- deleteFront(): 덱의 앞쪽 요소를 삭제
- deleteLast(): 덱의 뒤쪽 요소를 삭제
- getFront(): 덱의 앞쪽 요소를 가져오기
- getRear(): 덱의 뒤쪽 요소를 가져오기
- isEmpty(): 덱이 비어있는지 확인
- isFull(): 덱이 꽉 찼는지 확인

배열을 사용하여 원형 덱 구현

### 문제 풀이 방법

### 문제의 중요한 점
배열을 원형으로 사용하기 위해 포인터를 적절히 관리하는 것. 
- 이를 위해 모듈로 연산을 사용하여 포인터가 배열의 끝에서 다시 처음으로 돌아올 수 있도록 설정
- 이 방법을 사용하면 배열의 크기를 초과하지 않고도 원형 덱을 효율적으로 구현할 수 있음


## 2. Merge k Sorted Lists

### 문제 이해
여러 개(k개)의 정렬된 링크드 리스트가 주어질 때, 이를 하나의 정렬된 링크드 리스트로 병합해야 함

```
[
  - 1 -> 4 -> 5
  - 1 -> 3 -> 4
  - 2 -> 6
]
```

세 개의 리스트를 하나의 정렬된 리스트로 병합하면 다음과 같이 됨

```
- 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6
```


### 문제 풀이 방법

#### 간단한 접근 방법 - 리스트 사용

1. 각 링크드 리스트의 노드를 순회하여 모든 값을 배열에 담기
2. 배열을 정렬하기
3. 정렬된 배열로 새로운 링크드 리스트로 만들기

### 문제의 중요한 점

- 효율성
- 링크드 리스트의 이해
- 우선순위 큐의 활용

## 3. K Closest Points to Origin

### 문제 이해

### 문제 풀이 방법

### 문제의 중요한 점

## 4. 


### 문제 이해

### 문제 풀이 방법

### 문제의 중요한 점


